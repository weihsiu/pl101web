// Generated by CoffeeScript 1.3.1
var evalScheem, evalScheemString, fs, lookup, newEnv, parse, peg, rootEnv, show, update,
  __slice = [].slice;

if (typeof module !== "undefined" && module !== null) {
  peg = require('pegjs');
  fs = require('fs');
  parse = peg.buildParser(fs.readFileSync('src/scheem.pegjs', 'utf-8')).parse;
} else {
  parse = Scheem.parse;
}

rootEnv = {
  bindings: {
    '#t': '#t',
    '#f': '#f',
    '+': function(x, y) {
      return x + y;
    },
    '-': function(x, y) {
      return x - y;
    },
    '*': function(x, y) {
      return x * y;
    },
    '/': function(x, y) {
      return x / y;
    },
    '=': function(x, y) {
      if (x === y) {
        return '#t';
      } else {
        return '#f';
      }
    },
    '<': function(x, y) {
      if (x < y) {
        return '#t';
      } else {
        return '#f';
      }
    },
    '>': function(x, y) {
      if (x > y) {
        return '#t';
      } else {
        return '#f';
      }
    },
    '<=': function(x, y) {
      if (x <= y) {
        return '#t';
      } else {
        return '#f';
      }
    },
    '>=': function(x, y) {
      if (x >= y) {
        return '#t';
      } else {
        return '#f';
      }
    },
    'not': function(x) {
      if (x === '#t') {
        return '#f';
      } else {
        return '#t';
      }
    },
    'nil?': function(x) {
      if (x.length === 0) {
        return '#t';
      } else {
        return '#f';
      }
    },
    'atom?': function(x) {
      if (typeof x === 'object') {
        return '#f';
      } else {
        return '#t';
      }
    },
    'cons': function(x, y) {
      y.unshift(x);
      return y;
    },
    'car': function(x) {
      return x[0];
    },
    'cdr': function(x) {
      return x.slice(1);
    },
    'alert': function(x) {
      if (typeof module !== "undefined" && module !== null) {
        return console.log(x);
      } else {
        return alert(x);
      }
    },
    'show': function(x) {
      return show(x);
    }
  },
  outer: null
};

show = function(x) {
  var e, msg, _i, _len;
  switch (typeof x) {
    case 'string':
      return '"' + x + '"';
    case 'number':
      return '' + x;
    default:
      msg = '(';
      for (_i = 0, _len = x.length; _i < _len; _i++) {
        e = x[_i];
        msg += show(e) + ' ';
      }
      if (msg.length > 1) {
        msg = msg.slice(0, msg.length - 1);
      }
      return msg += ')';
  }
};

newEnv = function(bindings, outer) {
  if (bindings == null) {
    bindings = {};
  }
  if (outer == null) {
    outer = rootEnv;
  }
  return {
    bindings: bindings,
    outer: outer
  };
};

lookup = function(env, name) {
  if (!(env != null)) {
    throw "variable " + name + " is not bound";
  } else if (env.bindings.hasOwnProperty(name)) {
    return env.bindings[name];
  } else {
    return lookup(env.outer, name);
  }
};

update = function(env, name, value) {
  if (!(env != null)) {
    throw "variable " + name + " is not bound";
  } else if (env.bindings.hasOwnProperty(name)) {
    return env.bindings[name] = value;
  } else {
    return update(env.outer, name, value);
  }
};

evalScheem = function(expr, env) {
  var arg, args, bindings, e;
  if (typeof expr === 'number') {
    return expr;
  } else if (typeof expr === 'string') {
    return lookup(env, expr);
  } else {
    switch (expr[0]) {
      case 'define':
        env.bindings[expr[1]] = evalScheem(expr[2], env);
        return 0;
      case 'set!':
        update(env, expr[1], evalScheem(expr[2], env));
        return 0;
      case 'quote':
        return expr[1];
      case 'begin':
        return ((function() {
          var _i, _len, _ref, _results;
          _ref = expr.slice(1);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            _results.push(evalScheem(e, env));
          }
          return _results;
        })()).slice(-1)[0];
      case 'if':
        if (evalScheem(expr[1], env) === '#t') {
          return evalScheem(expr[2], env);
        } else {
          return evalScheem(expr[3], env);
        }
        break;
      case 'let-one':
        bindings = {};
        bindings[expr[1]] = evalScheem(expr[2], env);
        return evalScheem(expr[3], newEnv(bindings, env));
      case 'lambda-one':
        return function(x) {
          bindings = {};
          bindings[expr[1]] = x;
          return evalScheem(expr[2], newEnv(bindings, env));
        };
      case 'lambda':
        if (typeof expr[1] !== 'object') {
          throw 'first argument to lambda has to be a parameter list';
        }
        return function() {
          var args, i, params, _i, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          params = expr[1];
          bindings = {};
          for (i = _i = 0, _ref = params.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            bindings[params[i]] = args[i];
          }
          return evalScheem(expr[2], newEnv(bindings, env));
        };
      default:
        args = (function() {
          var _i, _len, _ref, _results;
          _ref = expr.slice(1);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            arg = _ref[_i];
            _results.push(evalScheem(arg, env));
          }
          return _results;
        })();
        return evalScheem(expr[0], env).apply(null, args);
    }
  }
};

evalScheemString = function(scheem, env) {
  return evalScheem(parse(scheem), env);
};

if (typeof module !== "undefined" && module !== null) {
  module.exports.newEnv = newEnv;
}

if (typeof module !== "undefined" && module !== null) {
  module.exports.evalScheem = evalScheem;
}

if (typeof module !== "undefined" && module !== null) {
  module.exports.evalScheemString = evalScheemString;
}
